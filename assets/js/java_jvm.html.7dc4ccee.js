"use strict";(self.webpackChunkx_blog=self.webpackChunkx_blog||[]).push([[3120],{1644:(a,e,i)=>{i.r(e),i.d(e,{comp:()=>h,data:()=>p});var l=i(641);const t=i.p+"assets/img/jvm01.8ce10d4c.jpg",r=i.p+"assets/img/jvm02.70f20305.jpg",s=i.p+"assets/img/jvm03.67e7d17a.jpg",n={},h=(0,i(6262).A)(n,[["render",function(a,e){const i=(0,l.g2)("font");return(0,l.uX)(),(0,l.CE)("div",null,[e[1]||(e[1]=(0,l.Fv)('<h2 id="jvm" tabindex="-1"><a class="header-anchor" href="#jvm"><span>JVM</span></a></h2><p>jvm是虚拟机 跨平台的 虚拟机对应不同版本 屏蔽了底层的指令化差异</p><h2 id="jdk-jre-运行时环境-jvm" tabindex="-1"><a class="header-anchor" href="#jdk-jre-运行时环境-jvm"><span>jdk jre（运行时环境） jvm</span></a></h2><p><img src="'+t+'" alt="虚拟机" loading="lazy"><br> 一个方法就是一个栈帧</p><h2 id="javap-反编译-class文件" tabindex="-1"><a class="header-anchor" href="#javap-反编译-class文件"><span>javap 反编译 class文件</span></a></h2><figure><img src="'+r+'" alt="反编译" tabindex="0" loading="lazy"><figcaption>反编译</figcaption></figure><h2 id="native修饰的调用的是本地方法栈" tabindex="-1"><a class="header-anchor" href="#native修饰的调用的是本地方法栈"><span>native修饰的调用的是本地方法栈</span></a></h2><h2 id="元空间存着类信息" tabindex="-1"><a class="header-anchor" href="#元空间存着类信息"><span>元空间存着类信息</span></a></h2><h2 id="性能调优" tabindex="-1"><a class="header-anchor" href="#性能调优"><span>性能调优</span></a></h2><p>针对堆内存调优<br> 堆 新生代（eden from to 8：1：1）和老年代 比例是1：2</p><h2 id="为什么需要性能调优呢" tabindex="-1"><a class="header-anchor" href="#为什么需要性能调优呢"><span>为什么需要性能调优呢？</span></a></h2><p>程序=数据结构+算法<br> 当对象创建过多时 设置一个临界点（处理不使用的对象）避免内存溢出<br> 在有限的空间做无限的事<br> eden 满了会触发minor gc<br> gc root 可达性算法 回收<br> 15次gc之后还在使用的对象 会晋升到老年代 4bit 最大 15<br> from对象大于占from内存的50% 会晋升到老年代</p>',12)),(0,l.bF)(i,{color:"red"},{default:(0,l.k6)((()=>e[0]||(e[0]=[(0,l.eW)(" 老年代满了 full gc stop the word （STW）停止服务 出现卡顿 规避full gc ")]))),_:1,__:[0]}),e[2]||(e[2]=(0,l.Fv)('<h2 id="为什么分为新生代和老年代" tabindex="-1"><a class="header-anchor" href="#为什么分为新生代和老年代"><span>为什么分为新生代和老年代？</span></a></h2><p>这是一种淘汰的策略</p><h2 id="jvm类加载" tabindex="-1"><a class="header-anchor" href="#jvm类加载"><span>jvm类加载</span></a></h2><p>加载，链接【验证，准备，解析】，初始化</p><h3 id="加载阶段" tabindex="-1"><a class="header-anchor" href="#加载阶段"><span>加载阶段</span></a></h3><ul><li>将.class文件中的二进制数据从磁盘读取到内存中，将其放在运行时数据区的方法区中，然后在堆内存创建对象</li><li>Class对象是存放在堆区的，不是方法区，这点很多人会犯错。类的元数据才是存在方法区的。</li><li>元数据并不是类的Class对象。Class对象是加载的最终产品，类的方法代码，变量名，方法名，访问权限，返回值等等都是在方法区的</li></ul><h3 id="链接阶段分为【验证-准备-解析】" tabindex="-1"><a class="header-anchor" href="#链接阶段分为【验证-准备-解析】"><span>链接阶段分为【验证，准备，解析】</span></a></h3><ol><li>验证阶段：<br> 验证类型，数据等等，此阶段不是必须的，可使用-Xverifynone 来关闭大部分验证 （了解即可）</li><li>准备阶段： <ul><li>jvm只会为类的成员变量分配内存空间（以及static修饰的变量）</li><li>此时变量值为数据默认值，例如：static int age = 18，此时的数据值为0，而不是18</li><li>当使用final static int age = 18 ；此时的数据值为18；final修饰 最终的（不可更改），所以jvm在准备阶段将值赋予变量</li></ul></li><li>解析阶段：<br> 把类中的符号引用装换为直接引用，就是在常量池中寻找类，接口，字段，和方法的符号引用，把这些符号应用替换为直接引用</li></ol><h3 id="初始化阶段-对静态变量赋予正确的初始值" tabindex="-1"><a class="header-anchor" href="#初始化阶段-对静态变量赋予正确的初始值"><span>初始化阶段 对静态变量赋予正确的初始值</span></a></h3><p>一般来说，当对类的首次主动使用的时候才会导致类的初始化，所以主动使用又叫做类的加载过程中的“初始化”开始的时机</p><h4 id="类的主动使用包括6种" tabindex="-1"><a class="header-anchor" href="#类的主动使用包括6种"><span>类的主动使用包括6种：</span></a></h4><ol><li>创建类的实例，也就是new的方式</li><li>访问某个类或者接口的静态变量，或堆静态变量赋值（final修饰除外，或者说放入常量池中的静态数据除外）</li><li>访问类的静态方法</li><li>反射（例如：Class.ForName(&quot;<a href="http://com.xxx.xxx" target="_blank" rel="noopener noreferrer">com.xxx.xxx</a>&quot;)）</li><li>初始化某个类的子类，其父类也会被初始化</li><li>java虚拟机启动时被标记为启动类的类（例如：javaTest），还有main方法的类会首先被初始化</li><li>jdk1.7后提供了动态语音支持</li></ol><ul><li><p>注意一点对静态字段，只有直接定义这个字段的类才会初始化（执行静态代码块），在继承，多肽中表现最为明显</p></li><li><p>接口初始化与普通类有所不同的是：<br> 类初始化时，其所有父类都已经被初始化，但接口初始化时不需要其父类全部初始化，是在需要用到父类接口时才会初始化</p></li><li><p>被动使用：<br> 除以上7中动态使用外，其他使用java类的方式都被看做是对类的被动使用，被动使用不会导致类初始化</p></li><li><p>注意：</p><ul><li>初始化 类 构造器：jvm会按顺序收集类变量的赋值语句，静态代码块，最终组成类的构造器由jvm执行</li><li>初始化 对象 构造器：JVM 会按照收集成员变量的赋值语句、普通代码块，最后收集构造方法，将它们组成对象构造器，最终由 JVM 执行。值得特别注意的是，<br> 如果没有监测或者收集到构造函数的代码，则将不会执行对象初始化方法。对象初始化方法一般在实例化类对象的时候执行。</li></ul></li></ul><h2 id="垃圾收集器" tabindex="-1"><a class="header-anchor" href="#垃圾收集器"><span>垃圾收集器</span></a></h2><ol><li>Serial 收集器： <ul><li>适用于单核或者较小的应用场景。</li><li>用于要求低延迟、低吞吐量的应用。</li><li>适合移动设备或嵌入式系统等资源受限的环境。</li></ul></li><li>Parallel 收集器： <ul><li>适用于需要最大吞吐量的多核处理器环境。<br> *用于后端数据处理等对吞吐量要求较高的应用。</li></ul></li><li>G1 收集器： <ul><li>适用于大内存、多核处理器环境。</li><li>用于需要更可控的 GC 停顿时间的应用。</li><li>适合需要更可预测的 GC 行为的大型应用。<br> 4.CMS 收集器：</li><li>适用于对停顿时间敏感的应用。</li><li>用于需要短暂 GC 停顿时间的应用。</li><li>适合 Web 服务器等对响应时间要求高的应用。</li></ul></li></ol><h2 id="java线上诊断方法" tabindex="-1"><a class="header-anchor" href="#java线上诊断方法"><span>java线上诊断方法</span></a></h2><ol><li>原生方法 <ul><li>Linux原生命令 top、printf</li><li>jdk自带命令工具 jstack、jstat</li></ul></li><li>Arthas（阿尔萨斯） <ul><li>阿里开源针对java的线上诊断工具</li><li>Arthas <a href="https://github.com/alibaba/arthas" target="_blank" rel="noopener noreferrer">githup官网</a></li><li>Arthas 支持JDK 6+，支持Linux/Mac/Windows，采用命令行交互模式，</li><li>同时提供丰富的 Tab 自动补全功能，进一步方便进行问题的定位和诊断</li></ul></li><li>show-busy-java-theads(淘宝开源) <ul><li><a href="http://show-busy-java-threads.sh" target="_blank" rel="noopener noreferrer">show-busy-java-threads.sh</a>，这个工具是useful-scripts工具集的其中一个工具。</li><li>useful-scripts <a href="https://github.com/oldratlee/useful-scripts" target="_blank" rel="noopener noreferrer">github网址</a></li><li>show-busy-java-threads用于快速排查Java的CPU性能问题(top us值过高)，</li><li>自动查出运行的Java进程中消耗CPU多的线程，并打印出其线程栈，从而确定导致性能问题的方法调用。</li></ul></li></ol><h3 id="注意" tabindex="-1"><a class="header-anchor" href="#注意"><span>注意：</span></a></h3><ul><li><p>此工具的核心还是使用jdk的jstack方法，只是在其上做了封装展示</p></li><li><p>设置gc日志</p></li></ul><div class="language-shell line-numbers-mode" data-highlighter="shiki" data-ext="shell" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-shell"><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">java</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> -XX:+PrintGC</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> -XX:+PrintGCDetails</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> -Xloggc:/path/to/gc.log</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> Main</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><ul><li>查看堆内存命令 jmap -heap 进程号<br><img src="'+s+'" alt="查看堆内存" loading="lazy"></li></ul>',21))])}]]),p=JSON.parse('{"path":"/java/jvm.html","title":"JVM","lang":"zh-CN","frontmatter":{"icon":"cash-register","category":["java","foundation","基础","jvm"],"tag":["java","foundation","笔记","记录","基础","jvm"],"title":"JVM","star":true,"description":"JVM jvm是虚拟机 跨平台的 虚拟机对应不同版本 屏蔽了底层的指令化差异 jdk jre（运行时环境） jvm 虚拟机 一个方法就是一个栈帧 javap 反编译 class文件 反编译反编译 native修饰的调用的是本地方法栈 元空间存着类信息 性能调优 针对堆内存调优 堆 新生代（eden from to 8：1：1）和老年代 比例是1：2 为...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"JVM\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-07-10T08:45:02.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"XK\\",\\"url\\":\\"https://xk1009.github.io/Xblog\\",\\"email\\":\\"564293991@qq.com\\"}]}"],["meta",{"property":"og:url","content":"https://mister-hope.github.io/Xblog/java/jvm.html"}],["meta",{"property":"og:site_name","content":"树下打盹儿"}],["meta",{"property":"og:title","content":"JVM"}],["meta",{"property":"og:description","content":"JVM jvm是虚拟机 跨平台的 虚拟机对应不同版本 屏蔽了底层的指令化差异 jdk jre（运行时环境） jvm 虚拟机 一个方法就是一个栈帧 javap 反编译 class文件 反编译反编译 native修饰的调用的是本地方法栈 元空间存着类信息 性能调优 针对堆内存调优 堆 新生代（eden from to 8：1：1）和老年代 比例是1：2 为..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-07-10T08:45:02.000Z"}],["meta",{"property":"article:tag","content":"jvm"}],["meta",{"property":"article:tag","content":"基础"}],["meta",{"property":"article:tag","content":"记录"}],["meta",{"property":"article:tag","content":"笔记"}],["meta",{"property":"article:tag","content":"foundation"}],["meta",{"property":"article:tag","content":"java"}],["meta",{"property":"article:modified_time","content":"2025-07-10T08:45:02.000Z"}]]},"git":{"createdTime":1750743585000,"updatedTime":1752137102000,"contributors":[{"name":"xk","username":"xk","email":"564293991@qq.com","commits":3,"url":"https://github.com/xk"}]},"readingTime":{"minutes":5.49,"words":1648},"filePathRelative":"java/jvm.md","excerpt":"<h2>JVM</h2>\\n<p>jvm是虚拟机  跨平台的 虚拟机对应不同版本 屏蔽了底层的指令化差异</p>\\n<h2>jdk jre（运行时环境） jvm</h2>\\n<p><br>\\n一个方法就是一个栈帧</p>\\n<h2>javap 反编译 class文件</h2>\\n<figure><figcaption>反编译</figcaption></figure>\\n<h2>native修饰的调用的是本地方法栈</h2>\\n<h2>元空间存着类信息</h2>\\n<h2>性能调优</h2>\\n<p>针对堆内存调优<br>\\n堆 新生代（eden from to 8：1：1）和老年代  比例是1：2</p>\\n<h2>为什么需要性能调优呢？</h2>","autoDesc":true}')},6262:(a,e)=>{e.A=(a,e)=>{const i=a.__vccOpts||a;for(const[a,l]of e)i[a]=l;return i}}}]);