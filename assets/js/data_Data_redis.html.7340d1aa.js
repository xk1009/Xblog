"use strict";(self.webpackChunkx_blog=self.webpackChunkx_blog||[]).push([[1639],{5601:(e,a,t)=>{t.r(a),t.d(a,{comp:()=>p,data:()=>h});var i=t(641);const r=t.p+"assets/img/lock01.37e745dc.jpg",s=t.p+"assets/img/lock02.6fc947de.jpg",n=t.p+"assets/img/lock03.54d00177.jpg",d={},p=(0,t(6262).A)(d,[["render",function(e,a){return(0,i.uX)(),(0,i.CE)("div",null,a[0]||(a[0]=[(0,i.Fv)('<h2 id="基本流程" tabindex="-1"><a class="header-anchor" href="#基本流程"><span>基本流程</span></a></h2><p>1.第一次查询 redis中没缓存数据，到数据库中查询，获取到数据后，在放入redis中<br> 2.对列表数据进行修改，清除redis中相应列表，等下次查询数据后更新缓存中数据</p><h2 id="列表数据缓存方案" tabindex="-1"><a class="header-anchor" href="#列表数据缓存方案"><span>列表数据缓存方案</span></a></h2><p>启动时 就先查询数据库 放入redis中<br> 修改数据时 对相应列表移除 下次查询时再从数据库中 放到redis</p><h2 id="缓存穿透" tabindex="-1"><a class="header-anchor" href="#缓存穿透"><span>缓存穿透</span></a></h2><p>获取数据时没有从缓存中获取数据，直接到数据库获取数据<br> 访问实际没有的数据，空数据，解决方案 将空值也缓存起来，并设置过期时间</p><h2 id="缓存雪崩" tabindex="-1"><a class="header-anchor" href="#缓存雪崩"><span>缓存雪崩</span></a></h2><p>高并发的情况下，假如数据刚好过期，高并发访问，解决方案：双重校验锁<br> 搭建高可用集群：redis 集群 哨兵模式<br> 预加载数据，启动时加载肯能会被高访问的数据，将其放入缓存中</p><h2 id="数据类型" tabindex="-1"><a class="header-anchor" href="#数据类型"><span>数据类型</span></a></h2><p>String（字符串） Hash（哈希 类似于map k-v） Set（集合） Zset（有序集合） List（列表）</p><h2 id="分布式锁" tabindex="-1"><a class="header-anchor" href="#分布式锁"><span>分布式锁</span></a></h2><figure><img src="'+r+'" alt="redis" tabindex="0" loading="lazy"><figcaption>redis</figcaption></figure><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-java"><span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">redisTemplate</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">opsForValue</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">setIfAbsent</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(k,v)</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> 返回一个boolean</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>这种方式会产生死锁<br> 例如：如果出现异常后面代码没有执行，没有delete就会死锁，try catch finally 貌似可以解决，但是宕机情况也会死锁<br> 所以使用超时时间过期的方式<br><img src="'+s+'" alt="设置过期" loading="lazy"><br> 需要实现一个阻塞锁，尝试一直去拿锁，自旋锁<br> 不可重入，及多次拿到锁之后，会得到false<br> 解决方案是 计数的方式，加锁+1，解锁-1，当值为0的时候再delete<br> 过期时间不足以执行完代码也会释放锁，导致锁失效，注意设置好过期时间<br> 可以采取 异步的设置过期时间 异步续命的方式</p><h2 id="一个分布式锁-满足以下需求" tabindex="-1"><a class="header-anchor" href="#一个分布式锁-满足以下需求"><span>一个分布式锁，满足以下需求</span></a></h2><figure><img src="'+n+'" alt="锁的需求" tabindex="0" loading="lazy"><figcaption>锁的需求</figcaption></figure><h3 id="redisson框架可解决分布式锁" tabindex="-1"><a class="header-anchor" href="#redisson框架可解决分布式锁"><span>redisson框架可解决分布式锁</span></a></h3>',17)]))}]]),h=JSON.parse('{"path":"/data/Data/redis.html","title":"redis","lang":"zh-CN","frontmatter":{"icon":"registered","category":["数据","缓存","中间件","redis"],"tag":["数据","缓存","中间件","笔记","记录","redis"],"title":"redis","star":true,"pageview":true,"description":"基本流程 1.第一次查询 redis中没缓存数据，到数据库中查询，获取到数据后，在放入redis中 2.对列表数据进行修改，清除redis中相应列表，等下次查询数据后更新缓存中数据 列表数据缓存方案 启动时 就先查询数据库 放入redis中 修改数据时 对相应列表移除 下次查询时再从数据库中 放到redis 缓存穿透 获取数据时没有从缓存中获取数据，直...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"redis\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-07-14T08:43:59.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"XK\\",\\"url\\":\\"https://xk1009.github.io/Xblog\\",\\"email\\":\\"564293991@qq.com\\"}]}"],["meta",{"property":"og:url","content":"https://mister-hope.github.io/Xblog/data/Data/redis.html"}],["meta",{"property":"og:site_name","content":"树下打盹儿"}],["meta",{"property":"og:title","content":"redis"}],["meta",{"property":"og:description","content":"基本流程 1.第一次查询 redis中没缓存数据，到数据库中查询，获取到数据后，在放入redis中 2.对列表数据进行修改，清除redis中相应列表，等下次查询数据后更新缓存中数据 列表数据缓存方案 启动时 就先查询数据库 放入redis中 修改数据时 对相应列表移除 下次查询时再从数据库中 放到redis 缓存穿透 获取数据时没有从缓存中获取数据，直..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-07-14T08:43:59.000Z"}],["meta",{"property":"article:tag","content":"redis"}],["meta",{"property":"article:tag","content":"记录"}],["meta",{"property":"article:tag","content":"笔记"}],["meta",{"property":"article:tag","content":"中间件"}],["meta",{"property":"article:tag","content":"缓存"}],["meta",{"property":"article:tag","content":"数据"}],["meta",{"property":"article:modified_time","content":"2025-07-14T08:43:59.000Z"}]]},"git":{"createdTime":1752482639000,"updatedTime":1752482639000,"contributors":[{"name":"xk","username":"xk","email":"564293991@qq.com","commits":1,"url":"https://github.com/xk"}]},"readingTime":{"minutes":1.77,"words":530},"filePathRelative":"data/Data/redis.md","excerpt":"<h2>基本流程</h2>\\n<p>1.第一次查询 redis中没缓存数据，到数据库中查询，获取到数据后，在放入redis中<br>\\n2.对列表数据进行修改，清除redis中相应列表，等下次查询数据后更新缓存中数据</p>\\n<h2>列表数据缓存方案</h2>\\n<p>启动时 就先查询数据库 放入redis中<br>\\n修改数据时 对相应列表移除 下次查询时再从数据库中 放到redis</p>\\n<h2>缓存穿透</h2>\\n<p>获取数据时没有从缓存中获取数据，直接到数据库获取数据<br>\\n访问实际没有的数据，空数据，解决方案 将空值也缓存起来，并设置过期时间</p>\\n<h2>缓存雪崩</h2>\\n<p>高并发的情况下，假如数据刚好过期，高并发访问，解决方案：双重校验锁<br>\\n搭建高可用集群：redis 集群 哨兵模式<br>\\n预加载数据，启动时加载肯能会被高访问的数据，将其放入缓存中</p>","autoDesc":true}')},6262:(e,a)=>{a.A=(e,a)=>{const t=e.__vccOpts||e;for(const[e,i]of a)t[e]=i;return t}}}]);