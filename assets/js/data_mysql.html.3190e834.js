"use strict";(self.webpackChunkx_blog=self.webpackChunkx_blog||[]).push([[1361],{6262:(i,a)=>{a.A=(i,a)=>{const s=i.__vccOpts||i;for(const[i,e]of a)s[i]=e;return s}},6488:(i,a,s)=>{s.r(a),s.d(a,{comp:()=>u,data:()=>A});var e=s(641);const l=s.p+"assets/img/mysql01.8d30a70d.jpg",n=s.p+"assets/img/mysql02.c3f203a0.jpg",t=s.p+"assets/img/mysql03.61789cbb.jpg",h=s.p+"assets/img/mysql04.ed22709a.jpg",r=s.p+"assets/img/mysql05.dcd7ed75.jpg",p=s.p+"assets/img/mysql06.f39bf6bf.jpg",d=s.p+"assets/img/mysql07.0cd28bec.jpg",c=s.p+"assets/img/mysql08.0924a6a8.jpg",o=s.p+"assets/img/mysql09.6e7afa99.jpg",g=s.p+"assets/img/mysql10.fd63f5c2.jpg",m=s.p+"assets/img/mysql11.f7fcc3cb.jpg",y=s.p+"assets/img/mysql12.e11a9b5f.jpg",k=s.p+"assets/img/mysql13.5d5e7ce3.jpg",b={},u=(0,s(6262).A)(b,[["render",function(i,a){return(0,e.uX)(),(0,e.CE)("div",null,a[0]||(a[0]=[(0,e.Fv)('<h2 id="mysql-常用存储引擎" tabindex="-1"><a class="header-anchor" href="#mysql-常用存储引擎"><span>mysql 常用存储引擎</span></a></h2><ul><li>MyIASM（5.5以前默认） innodb（5.5之后默认）</li><li>MyISAM 不支持外键，不支持事务，表锁定，缓存只缓存索引，相较性能高</li><li>innodb 支持外键，支持事务，行锁定，缓存索引还缓存真实数据（内存要求较高），相较性能低</li></ul><h2 id="mysql-索引" tabindex="-1"><a class="header-anchor" href="#mysql-索引"><span>mysql 索引</span></a></h2><p>一种是hash索引和B+tree索引，使用的是innodb引擎，默认B+tree</p><h3 id="hash索引" tabindex="-1"><a class="header-anchor" href="#hash索引"><span>hash索引</span></a></h3><ul><li>底层使用的哈希表，哈希表是一种k-v存储数据的结构；</li><li>所以多个数据在存储关系上是完全没有顺序关系的；</li><li>所以在区间查询是无法直接通过索引查询的，就需要全表扫描；</li><li>所以hash索引更适用于等值查询的场景</li></ul><h3 id="b-tree索引" tabindex="-1"><a class="header-anchor" href="#b-tree索引"><span>B+tree索引</span></a></h3><p>多路平衡查询树，它的节点是天然有序的，左节点小于父节点，父节点小于右节点，所以范围查询的时候不需要全表扫描</p><h3 id="hash和b-tree索引两者区别" tabindex="-1"><a class="header-anchor" href="#hash和b-tree索引两者区别"><span>hash和B+tree索引两者区别</span></a></h3><p>哈希索引更适用于等值查询，但是无法范围查询，原因是无法使用hash索引进行排序，hash索引不支持多列联合索引的最左匹配规则，如果有大量重复键值的情况下，hash索引的效率会很低，因为存在hash碰撞问题</p><h3 id="聚簇索引和非聚簇索引" tabindex="-1"><a class="header-anchor" href="#聚簇索引和非聚簇索引"><span>聚簇索引和非聚簇索引</span></a></h3><ul><li>在 InnoDB 里，索引B+ Tree的叶子节点存储了整行数据的是主键索引，也被称之为聚簇索引。</li><li>而索引B+ Tree的叶子节点存储了主键的值的是非主键索引，也被称之为非聚簇索引。</li><li>聚簇索引更快，因为主键索引树的叶子节点直接就是我们要查询的整行数据了。</li><li>而非主键索引的叶子节点是主键的值，查到主键的值以后，还需要再通过主键的值再进行一次查询。</li></ul><h3 id="联合索引和最左前缀匹配" tabindex="-1"><a class="header-anchor" href="#联合索引和最左前缀匹配"><span>联合索引和最左前缀匹配</span></a></h3><ul><li>对多个字段添加索引，就是联合索引</li><li>where子句中使用最频繁的一列放在最左边，因为MySQL索引查询会遵循最左前缀匹配的原则，</li><li>即最左优先，在检索数据时从联合索引的最左边开始匹配。</li><li>所以当我们创建一个联合索引的时候，如(key1,key2,key3)，</li><li>相当于创建了（key1）、(key1,key2)和(key1,key2,key3)三个索引，这就是最左匹配原则。</li></ul><h2 id="数据结构" tabindex="-1"><a class="header-anchor" href="#数据结构"><span>数据结构</span></a></h2><p>二叉树，红黑树，BTree，B+Tree， Hash(哈希)</p><h3 id="二叉树" tabindex="-1"><a class="header-anchor" href="#二叉树"><span>二叉树</span></a></h3><p>左小右大，如果顺序递增id，会产生线性结构</p><h3 id="红黑树" tabindex="-1"><a class="header-anchor" href="#红黑树"><span>红黑树</span></a></h3><figure><img src="'+l+'" alt="红黑树" tabindex="0" loading="lazy"><figcaption>红黑树</figcaption></figure><h3 id="btree" tabindex="-1"><a class="header-anchor" href="#btree"><span>BTree</span></a></h3><figure><img src="'+n+'" alt="BTree" tabindex="0" loading="lazy"><figcaption>BTree</figcaption></figure><h3 id="b-tree" tabindex="-1"><a class="header-anchor" href="#b-tree"><span>B+Tree</span></a></h3><figure><img src="'+t+'" alt="B+Tree" tabindex="0" loading="lazy"><figcaption>B+Tree</figcaption></figure><h3 id="hash-哈希" tabindex="-1"><a class="header-anchor" href="#hash-哈希"><span>hash(哈希)</span></a></h3><p>存在碰撞，不支持范围查询（因为hash算法之后不能保证 hash值有序）<br><img src="'+h+'" alt="hash" loading="lazy"><br><img src="'+r+'" alt="hash1" loading="lazy"></p><h2 id="获取数据库表结构相关信息" tabindex="-1"><a class="header-anchor" href="#获取数据库表结构相关信息"><span>获取数据库表结构相关信息</span></a></h2><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-sql"><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">SELECT</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  COLUMN_NAME 列名,</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  COLUMN_TYPE 数据类型,</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  DATA_TYPE 字段类型,</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  CHARACTER_MAXIMUM_LENGTH 长度,</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  IS_NULLABLE 是否为空,</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  COLUMN_DEFAULT 默认值,</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  COLUMN_COMMENT 备注 </span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">FROM</span></span>\n<span class="line"><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> INFORMATION_SCHEMA</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">COLUMNS</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">where</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- developerclub为数据库名称，到时候只需要修改成你要导出表结构的数据库即可</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">table_schema </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&#39;novel&#39;</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">AND</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- article为表名，到时候换成你要导出的表的名称</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- 如果不写的话，默认会查询出所有表中的数据，这样可能就分不清到底哪些字段是哪张表中的了，所以还是建议写上要导出的名名称</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">table_name  </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &#39;user_read_record&#39;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="sql优化" tabindex="-1"><a class="header-anchor" href="#sql优化"><span>sql优化</span></a></h2><ol><li>避免select * 增加查询解析器的成本，将sql格式化的一个阶段，所有字段都会拿出来不会走覆盖索引，查询到联合索引之外的字段，会进行回表操作，大文本字段增加网络消耗</li><li>小表驱动大表</li><li>连接查询代替子查询</li><li>group by 可以添加索引</li><li>批量插入，循环插入较慢，可以使用一条sql 批量插入，动态sql控制在500内</li><li>大数据使用limit ，不要一次性查出，可能导致内存异常</li><li>用union all 代替union union会去重</li><li>join的表不宜过多（小表连大表）</li></ol><h3 id="delete-和-update-语句后加-limit" tabindex="-1"><a class="header-anchor" href="#delete-和-update-语句后加-limit"><span>delete 和 update 语句后加 limit</span></a></h3><p>在业务场景要求高的数据库中，对于单条删除和更新操作，在 delete 和 update 后面加 limit 1 绝对是个好习惯。比如，在删除执行中，第一条就命中了删除行，如果 SQL 中有 limit 1；这时就 return 了，否则还会执行完全表扫描才 return。效率不言而喻</p><h2 id="主从配置" tabindex="-1"><a class="header-anchor" href="#主从配置"><span>主从配置</span></a></h2><p><img src="'+p+'" alt="主库配置" loading="lazy"><br><img src="'+d+'" alt="重启服务器" loading="lazy"><br><img src="'+c+'" alt="授权" loading="lazy"><br><img src="'+o+'" alt="查看二进制日志坐标" loading="lazy"><br><img src="'+g+'" alt="从库配置" loading="lazy"><br><img src="'+m+'" alt="重启服务器2" loading="lazy"><br><img src="'+y+'" alt="设置主库" loading="lazy"><br><img src="'+k+'" alt="开启同步" loading="lazy"><br> show slave status\\G 格式化展示 一行展示</p>',34)]))}]]),A=JSON.parse('{"path":"/data/mysql.html","title":"MYSQL","lang":"zh-CN","frontmatter":{"icon":"table","date":"2024-09-23T00:00:00.000Z","category":["数据","mysql"],"tag":["数据","mysql","笔记","记录"],"title":"MYSQL","star":true,"pageview":true,"description":"mysql 常用存储引擎 MyIASM（5.5以前默认） innodb（5.5之后默认） MyISAM 不支持外键，不支持事务，表锁定，缓存只缓存索引，相较性能高 innodb 支持外键，支持事务，行锁定，缓存索引还缓存真实数据（内存要求较高），相较性能低 mysql 索引 一种是hash索引和B+tree索引，使用的是innodb引擎，默认B+tre...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"MYSQL\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-09-23T00:00:00.000Z\\",\\"dateModified\\":\\"2025-07-06T02:55:40.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"XK\\",\\"url\\":\\"https://xk1009.github.io/Xblog\\",\\"email\\":\\"564293991@qq.com\\"}]}"],["meta",{"property":"og:url","content":"https://mister-hope.github.io/Xblog/data/mysql.html"}],["meta",{"property":"og:site_name","content":"树下打盹儿"}],["meta",{"property":"og:title","content":"MYSQL"}],["meta",{"property":"og:description","content":"mysql 常用存储引擎 MyIASM（5.5以前默认） innodb（5.5之后默认） MyISAM 不支持外键，不支持事务，表锁定，缓存只缓存索引，相较性能高 innodb 支持外键，支持事务，行锁定，缓存索引还缓存真实数据（内存要求较高），相较性能低 mysql 索引 一种是hash索引和B+tree索引，使用的是innodb引擎，默认B+tre..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-07-06T02:55:40.000Z"}],["meta",{"property":"article:tag","content":"记录"}],["meta",{"property":"article:tag","content":"笔记"}],["meta",{"property":"article:tag","content":"mysql"}],["meta",{"property":"article:tag","content":"数据"}],["meta",{"property":"article:published_time","content":"2024-09-23T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-07-06T02:55:40.000Z"}]]},"git":{"createdTime":1751770540000,"updatedTime":1751770540000,"contributors":[{"name":"xk","username":"xk","email":"564293991@qq.com","commits":1,"url":"https://github.com/xk"}]},"readingTime":{"minutes":4.07,"words":1221},"filePathRelative":"data/mysql.md","excerpt":"<h2>mysql 常用存储引擎</h2>\\n<ul>\\n<li>MyIASM（5.5以前默认） innodb（5.5之后默认）</li>\\n<li>MyISAM 不支持外键，不支持事务，表锁定，缓存只缓存索引，相较性能高</li>\\n<li>innodb 支持外键，支持事务，行锁定，缓存索引还缓存真实数据（内存要求较高），相较性能低</li>\\n</ul>\\n<h2>mysql 索引</h2>\\n<p>一种是hash索引和B+tree索引，使用的是innodb引擎，默认B+tree</p>\\n<h3>hash索引</h3>\\n<ul>\\n<li>底层使用的哈希表，哈希表是一种k-v存储数据的结构；</li>\\n<li>所以多个数据在存储关系上是完全没有顺序关系的；</li>\\n<li>所以在区间查询是无法直接通过索引查询的，就需要全表扫描；</li>\\n<li>所以hash索引更适用于等值查询的场景</li>\\n</ul>","autoDesc":true}')}}]);