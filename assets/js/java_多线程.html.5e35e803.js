"use strict";(self.webpackChunkx_blog=self.webpackChunkx_blog||[]).push([[119],{1356:(e,a,i)=>{i.r(a),i.d(a,{comp:()=>t,data:()=>o});var l=i(641);const n=i.p+"assets/img/dxc01.bca306f5.jpg",r={},t=(0,i(6262).A)(r,[["render",function(e,a){return(0,l.uX)(),(0,l.CE)("div",null,a[0]||(a[0]=[(0,l.Fv)('<h2 id="进程和线程" tabindex="-1"><a class="header-anchor" href="#进程和线程"><span>进程和线程</span></a></h2><ul><li><p>进程：<br> 就是正在运行的程序的实例，是一个具有一定独立功能的程序，关于某个数据集合的一次运行活动</p></li><li><p>线程：<br> 是操作系统能够进行运算调度的最小单位，它被包含在进程中，是进程种的实际运作的单位，一个线程指的是进程种的一个单一顺序的控制流，一个进程中可以并发多个线程，每个线程执行不同的任务。</p></li><li><p>多线程的优点<br> 可以把占据时间长的任务放到后台去吃力<br> 程序的运行速度加快</p></li></ul><h2 id="实现多线程" tabindex="-1"><a class="header-anchor" href="#实现多线程"><span>实现多线程</span></a></h2><ol><li>继承Thread类，重写run方法，run方法运行具体业务，start方法启动线程</li><li>实现Runnable接口，重写run方法，实例化一个thread，start方法启动线程</li><li>实现CallAble接口，指定泛型为返回值的类型，实现call方法，实例化CallAble线程，实例化FutureTask将CallAble线程作为参数，再实例化Thread，将futureTask作为参数，start方法启动。</li></ol><h2 id="线程运行特点" tabindex="-1"><a class="header-anchor" href="#线程运行特点"><span>线程运行特点</span></a></h2><ul><li>随机性，在多线程编程中，代码的执行结果与代码的执行顺序或调用顺序是无关的。</li><li>线程是一个子任务，cpu以不确定的方式或者是以随机的时间来调用线程中的run方法；</li><li>start的执行顺序与线程的启动顺序不一致</li></ul><h2 id="成员变量与线程安全" tabindex="-1"><a class="header-anchor" href="#成员变量与线程安全"><span>成员变量与线程安全</span></a></h2><ul><li>自定义线程类中的成员变量针对其它线程可以分为共享与不共享</li><li>不共享：单独创建线程，成员变量是只能自己使用，其它线程获取不到</li><li>共享：创建一个线程，将这个线程作为参数传到 new Thread（线程），从而获取线程实例，实现成员变量的共享，但是这样会存在线程安全问题</li></ul><h2 id="线程的常用api" tabindex="-1"><a class="header-anchor" href="#线程的常用api"><span>线程的常用API</span></a></h2><ol><li>currentThread，获取当前线程的信息 getName</li><li>isAlive，当前线程是否处于活动状态，（以启动且运行没有结束）</li><li>sleep，在指定的毫秒数内，让当前线程暂停</li><li>getId，获取当前线程的唯一标识</li></ol><h2 id="停止线程" tabindex="-1"><a class="header-anchor" href="#停止线程"><span>停止线程</span></a></h2><pre><code>意味着在线程处理完成任务之前结束正在执行的操作\n</code></pre><ol><li>使用退出标志，使线程正常停止，stopThread（）</li><li>使用stop方法，强制停止，线程会产生ThreadDeath异常，会对锁定对象解锁</li><li>interrupt方法，不会真正的结束线程，在当前线程中打一个停止的标记。通过isInterrupted是否有停止标记；<br> interrupted方法，获取当前线程是由有停止标记，当调用了interrupted方法后会移除停止标记。<br> 如果线程中有sleep方法，调用interrupted方法会产生异常信息。</li></ol><h2 id="暂停线程" tabindex="-1"><a class="header-anchor" href="#暂停线程"><span>暂停线程</span></a></h2><ul><li>suspend方法暂停线程，resume恢复线程运行。</li><li>suspend方法不会释放同步，其它线程无法调用。</li><li>suspend方法会造成共享对象不同步的问题</li></ul><h2 id="yield方法" tabindex="-1"><a class="header-anchor" href="#yield方法"><span>yield方法</span></a></h2><p>yield方法的作用是放弃当前的cpu资源，将资源让给其它的任务去占用cpu执行。但是放弃时间不确定，有可能放弃了，马上有获取到cpu资源</p><h2 id="线程的优先级" tabindex="-1"><a class="header-anchor" href="#线程的优先级"><span>线程的优先级</span></a></h2><ul><li>线程可以划分优先级，优先级较高的线程得到更多的cpu资源</li><li>设置优先级使用setPriority，优先级分为1-10个级别，不在此范围会报异常</li><li>JDK默认设置3个优先级常量： <ol><li>MIN_PRIORITY = 1 最小值</li><li>NORM_PRIORITY = 5 中间值</li><li>MAX_PRIORITY = 10 最大值</li></ol></li><li>线程优先级具有继承性，比如线程A启动线程B，线程B与线程A一样的优先级</li></ul><h2 id="守护线程" tabindex="-1"><a class="header-anchor" href="#守护线程"><span>守护线程</span></a></h2><ul><li>用户线程和守护线程</li><li>守护线程是一种特殊线程，当我们进程中不存在用户线程时，守护线程会自动销毁。</li><li>例如垃圾回收线程。当进程中没有用户线程，垃圾回收线程就没有存在的必要，所以会自动销毁。</li><li>setDaemon方法设置为守护线程，在start方法之前设置</li></ul><h2 id="线程的同步机制synchronized" tabindex="-1"><a class="header-anchor" href="#线程的同步机制synchronized"><span>线程的同步机制synchronized</span></a></h2><p>线程安全与非线程安全？<br> 不安全：当多个线程访问同一个对象中的成员变量时产生的，产生的后果就是脏读，取到的数据是被更改过的数据</p><ul><li>局部变量是线程安全的。局部变量是私有的</li><li>成员变量是线程不安全的。</li><li>synchronized修饰方法，对象锁</li><li>synchronized有锁重入的功能</li><li>synchronized在静态方法上使用是对class类上锁，而非静态方法上是对像上锁。</li><li>synchronized static 和 synchroized（class）作用是一样的</li><li>同步代码块指定对象上锁</li></ul><h2 id="死锁" tabindex="-1"><a class="header-anchor" href="#死锁"><span>死锁</span></a></h2><p>多个线程在运行过程中因争夺资源而造成的一种僵局</p><h3 id="原因" tabindex="-1"><a class="header-anchor" href="#原因"><span>原因：</span></a></h3><ol><li>系统资源竞争会导致系统的资源不足，资源分配不到，导致死锁</li><li>线程运行的顺序不合适，线程运行过程中请求和释放的资源的顺序不当，死锁</li></ol><h3 id="产生死锁的必要条件" tabindex="-1"><a class="header-anchor" href="#产生死锁的必要条件"><span>产生死锁的必要条件：</span></a></h3><ol><li>互斥条件，线程要求对所分配的资源进行排它性控制，及在一段时间内某个资源仅为一个线程所占用。</li><li>请求和保持条件：当线程因请求资源而阻塞时，对已经获得的资源保持不释放</li><li>不剥夺条件：线程已经获得的资源在未使用之前，不能剥夺，只能在使用完成时自己来释放</li><li>环路等待条件：在发生死锁时，必然存在一个线程等待另一个线程的环形链</li></ol><h2 id="锁对象类容改变" tabindex="-1"><a class="header-anchor" href="#锁对象类容改变"><span>锁对象类容改变</span></a></h2><p>线程A的锁时StringObject = 123，在A运行中改为456，睡50毫秒，<br> 那么另一个线程拿到的StringObject不是123了，而是456，<br> 相当于new了一个对象，那么就不是同一个对象锁了。<br> 但是改变对象中的属性不存在这个问题，只要对象不变。</p><h2 id="volatile关键字" tabindex="-1"><a class="header-anchor" href="#volatile关键字"><span>volatile关键字</span></a></h2><p>主要作用时使变量可以在多个线程之间可见。<br> 例：<br> 在启动线程时，变量public boolean flag =true 存在在公共堆栈及私有堆栈中，<br> 若使用服务器模式的JVM时，为了线程运行的效率，线程一直在私有堆栈中获取flag的值，<br> 一直为true，当改变了flag值后，虽然改变了，更新的确实公共堆栈中的flag，所以一直是死循环的状态。<br> 使用volatile修饰成员变量后，强制虚拟机从公共堆栈中获取变的值。</p><h2 id="volatile和snychroized区别" tabindex="-1"><a class="header-anchor" href="#volatile和snychroized区别"><span>volatile和snychroized区别</span></a></h2><ol><li>volatile时线程同步的轻量级实现，性能比synchroized更好，并且volatile只能修饰变量，synchronized修饰方法和代码块，jdk高版本以对synchronized进行优化，效率还是不错的。</li><li>多线程访问volatile时不会发生阻塞，而synchronized会出现阻塞。</li><li>volatile能保证可见性，不能保证原子性。而synchronized可以保证原子性，也可以间接保证可见性，因为它会将私有内存和公共内存中的数据做同步。</li><li>volatile解决的是变量多个线程之间的可见性，而synchronized解决的是多个线程之间访问资源的同步性。</li></ol><h2 id="线程间的通讯" tabindex="-1"><a class="header-anchor" href="#线程间的通讯"><span>线程间的通讯</span></a></h2><p>线程是程序中独立的个体，如果不经过处理就不能成为一个整体，线程间的通讯时是成为一个整体的比用方案之一，可以说线程之间的通讯后，线程之间的交互性更强大，使CUP利用率更高，大大提供程序猿对各线程任务在处理中的把控和监督。<br> 可使用volatile来实现线程间的通讯，但需要用到while轮询来获取数据，浪费cpu资源</p><h3 id="wait-和-notify机制-等待通知机制" tabindex="-1"><a class="header-anchor" href="#wait-和-notify机制-等待通知机制"><span>wait 和 notify机制 (等待通知机制)</span></a></h3><p>wait 和notify方法只能在同步方法或者同步代码块中使用，两者必须是锁定的同一对象，才能将其唤醒。wait方法执行后会释放锁，当notify方法不会释放锁，会执行完成同步代码后释放。<br> 如果多个线程等待，调用notify方法只会随机唤醒一个线程，使用notifyAll方法会唤醒所有线程。<br> wait（long time） wait方法会在time时间内等待被唤醒，如果超过time时间还没被唤醒，会自动唤醒。这和sleep作用相同的，但是区别是sleep是不会释放锁的，但wait会释放锁。</p><h3 id="join方法" tabindex="-1"><a class="header-anchor" href="#join方法"><span>join方法</span></a></h3><p>作用是等待线程对象销毁。<br> 例如：主线程创建了子线程，子线程做大量耗时的运算，主线程早于子线程结束，但主线程想等待子线程完成之后再结束，比如子线程处理一个数据，主线程需要取得这个数据中的值，那么就可以使用join方法来实现<br> 基本用法就是在主线程中调用子线程的join方法，那么主线程会等子线程完成之后再执行下面代码。主线程将会一直等待子线程结束，造成阻塞效果。类似于同步的效果，但是join使用的是wait/notify实现的，而同步使用的是对象锁</p><h3 id="threadlock类" tabindex="-1"><a class="header-anchor" href="#threadlock类"><span>ThreadLock类</span></a></h3><p>变量值共享可以使用静态变量形式，所有线程都可以使用同一个静变量。如果想每个线程都有自己的共享的变量，就可以使用ThreadLock类来实现，每个线程绑定自己的值。</p><h3 id="lock" tabindex="-1"><a class="header-anchor" href="#lock"><span>Lock</span></a></h3><p>ReentranLock在扩展功能上更强大，比如具有嗅探锁定，多路分支通知等，比synchronized更加灵活lock.lock()方法加锁，lock.unlock()方法解锁<br> lock要实现线程之间的通讯，需要结合condition类来实现，使用它有更好的灵活性，比如多路通知功能，也就是在一个Lock对象中创建多个condition实例，线程对象可以注册在指定的condition中，从而可以有选择性的进行线程通知，在调用线程上更灵活。<br> 使用notify/notifyAll，被通知的线程是由JVM随机选择的，但使用ReentranLock结合condition类可以实现选择性通知。这样效率也大大提高了。使用lock.newCondition()方法获取condition实例，使用condition.await() 实现线程等待，使用condition.signal()方法进行唤醒</p><h2 id="公平锁和非公平锁" tabindex="-1"><a class="header-anchor" href="#公平锁和非公平锁"><span>公平锁和非公平锁</span></a></h2><p>在实例reentranLock时 无参构造方法是非公平锁，通过boolean参数true时时公平锁，反之既然。公平锁是线程获取锁的顺序是按照加锁的顺序来分配的，也就是先来先得。非公平锁是随机的。</p><h2 id="reentranreadwritelock" tabindex="-1"><a class="header-anchor" href="#reentranreadwritelock"><span>ReentranReadWriteLock</span></a></h2><p>ReentranLock是一个互斥排他锁，即只有一个线程可以在lock方法后面的任务。虽然安全性可以保证，但是性能较低。在某些情况不需要操作变量，就可以使用读写锁来提升效率。<br> 读写锁有两个锁，一个是读操作也称为共享锁，一个是写操作也称为排他锁。也就是多个读锁之间不是互斥的，读锁与写锁是互斥的，写锁与写锁也是互斥的</p><h2 id="线程状态" tabindex="-1"><a class="header-anchor" href="#线程状态"><span>线程状态</span></a></h2><ul><li>NEW：尚未启动的线程处于这种状态</li><li>RUNNABLE：在Java虚拟机中 正在运行的线程处于这种状态</li><li>BLOCKED：被阻塞等待对象锁的线程处于这种状态</li><li>WAITING：等待另一个线程运行的线程处于这种状态</li><li>TIME_WAITING;等待另一个线程运行，到指定时间的线程处于这种状态</li><li>TERMINATED:已经退出运行的线程处于这种状态</li></ul><h2 id="各种状态的关系图" tabindex="-1"><a class="header-anchor" href="#各种状态的关系图"><span>各种状态的关系图：</span></a></h2><figure><img src="'+n+'" alt="状态关系图" tabindex="0" loading="lazy"><figcaption>状态关系图</figcaption></figure><h2 id="线程池" tabindex="-1"><a class="header-anchor" href="#线程池"><span>线程池</span></a></h2><p>减少创建和销毁线程次数，每个线程可重复利用，可同时执行多个任务，可以根据系统的承受能力，调整线程池中工作线程的数量，防止消耗过多的内存，服务器崩溃。</p><h3 id="java线程池的顶级接口时executor" tabindex="-1"><a class="header-anchor" href="#java线程池的顶级接口时executor"><span>java线程池的顶级接口时Executor</span></a></h3><p>比较重要的几个类：</p><ul><li>ExecutorService：真正的线程池接口</li><li>ScheduleExecutorService：解决需要重复执行的任务，周期性</li><li>ThreadPoolExecutor：ExecutorService默认的实现</li><li>ScheduleThreadPollExecutor:继承ThreadPoolExecutor的ScheduleExecutorService接口的实现，周期性的任务调度的类实现</li></ul><h3 id="executors提供了一些静态工厂-生成常用的线程池" tabindex="-1"><a class="header-anchor" href="#executors提供了一些静态工厂-生成常用的线程池"><span>Executors提供了一些静态工厂，生成常用的线程池</span></a></h3><ol><li>newCachedThreadPool(ThreadPoolExecutor的方法)<br> 创建一个可缓存的线程池，如果线程池大小超过了处理任务所需要的线程，就会回收部分空闲的线程（60s没有执行的线程），当任务数量增加时，线程池可以智能的添加新的线程来处理任务。这个线程池不会对线程池的大小进行限制，线程池的大小完全是依赖操作系统（JVM）能够创建的最大线程大小。</li><li>newFixedThreadPool（ThreadPoolExecutor的方法）<br> 创建固定大小的线程池，每次提交一个任务就创建一个线程，直到线程池达到最大大小。线程池一旦达到最大值，就会保持不变。如果某个线程异常结束，那么线程池就会补充一个新线程。</li><li>newSingleThreadPool（ThreadPoolExecutor）<br> 创建一个单线程的线程池。这个线程池只有一个工作线程，也就是单线程串行执行所有任务。如果这个线程异常结束，那么会有一个新线程替代它。此线程池保证所有任务的执行顺序会按照任务的提交顺序来执行。</li><li>newScheduleThreadPool（ScheduleTheadPoolExecutor）<br> 创建一个大小无限的线程池，这个线程支持定时以及周期性执行任务的需求。</li><li>newSingleThreadSchedulePool（scheduleThreadPoolExecutor）<br> 创建一个单线程，用于定时以及周期性的执行任务的需求。</li></ol>',61)]))}]]),o=JSON.parse('{"path":"/java/%E5%A4%9A%E7%BA%BF%E7%A8%8B.html","title":"多线程","lang":"zh-CN","frontmatter":{"icon":"lines-leaning","date":"2020-09-23T00:00:00.000Z","category":["java","foundation","基础","线程"],"tag":["java","foundation","笔记","记录","基础","线程"],"title":"多线程","star":true,"pageview":true,"description":"进程和线程 进程： 就是正在运行的程序的实例，是一个具有一定独立功能的程序，关于某个数据集合的一次运行活动 线程： 是操作系统能够进行运算调度的最小单位，它被包含在进程中，是进程种的实际运作的单位，一个线程指的是进程种的一个单一顺序的控制流，一个进程中可以并发多个线程，每个线程执行不同的任务。 多线程的优点 可以把占据时间长的任务放到后台去吃力 程序的...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"多线程\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2020-09-23T00:00:00.000Z\\",\\"dateModified\\":\\"2025-06-24T05:39:45.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"XK\\",\\"url\\":\\"https://xk1009.github.io/Xblog\\",\\"email\\":\\"564293991@qq.com\\"}]}"],["meta",{"property":"og:url","content":"https://mister-hope.github.io/Xblog/java/%E5%A4%9A%E7%BA%BF%E7%A8%8B.html"}],["meta",{"property":"og:site_name","content":"树下打盹儿"}],["meta",{"property":"og:title","content":"多线程"}],["meta",{"property":"og:description","content":"进程和线程 进程： 就是正在运行的程序的实例，是一个具有一定独立功能的程序，关于某个数据集合的一次运行活动 线程： 是操作系统能够进行运算调度的最小单位，它被包含在进程中，是进程种的实际运作的单位，一个线程指的是进程种的一个单一顺序的控制流，一个进程中可以并发多个线程，每个线程执行不同的任务。 多线程的优点 可以把占据时间长的任务放到后台去吃力 程序的..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-06-24T05:39:45.000Z"}],["meta",{"property":"article:tag","content":"线程"}],["meta",{"property":"article:tag","content":"基础"}],["meta",{"property":"article:tag","content":"记录"}],["meta",{"property":"article:tag","content":"笔记"}],["meta",{"property":"article:tag","content":"foundation"}],["meta",{"property":"article:tag","content":"java"}],["meta",{"property":"article:published_time","content":"2020-09-23T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-06-24T05:39:45.000Z"}]]},"git":{"createdTime":1750743585000,"updatedTime":1750743585000,"contributors":[{"name":"xk","username":"xk","email":"564293991@qq.com","commits":1,"url":"https://github.com/xk"}]},"readingTime":{"minutes":11.8,"words":3541},"filePathRelative":"java/多线程.md","excerpt":"<h2>进程和线程</h2>\\n<ul>\\n<li>\\n<p>进程：<br>\\n就是正在运行的程序的实例，是一个具有一定独立功能的程序，关于某个数据集合的一次运行活动</p>\\n</li>\\n<li>\\n<p>线程：<br>\\n是操作系统能够进行运算调度的最小单位，它被包含在进程中，是进程种的实际运作的单位，一个线程指的是进程种的一个单一顺序的控制流，一个进程中可以并发多个线程，每个线程执行不同的任务。</p>\\n</li>\\n<li>\\n<p>多线程的优点<br>\\n可以把占据时间长的任务放到后台去吃力<br>\\n程序的运行速度加快</p>\\n</li>\\n</ul>\\n<h2>实现多线程</h2>\\n<ol>\\n<li>继承Thread类，重写run方法，run方法运行具体业务，start方法启动线程</li>\\n<li>实现Runnable接口，重写run方法，实例化一个thread，start方法启动线程</li>\\n<li>实现CallAble接口，指定泛型为返回值的类型，实现call方法，实例化CallAble线程，实例化FutureTask将CallAble线程作为参数，再实例化Thread，将futureTask作为参数，start方法启动。</li>\\n</ol>","autoDesc":true}')},6262:(e,a)=>{a.A=(e,a)=>{const i=e.__vccOpts||e;for(const[e,l]of a)i[e]=l;return i}}}]);