"use strict";(self.webpackChunkx_blog=self.webpackChunkx_blog||[]).push([[4254],{1852:(e,i,r)=>{r.r(i),r.d(i,{comp:()=>h,data:()=>u});var a=r(641);const t=r.p+"assets/img/secuirty01.cd6e45b8.jpg",n=r.p+"assets/img/secuirty02.7cce3317.jpg",s=r.p+"assets/img/secuirty03.1e434a2e.jpg",o=r.p+"assets/img/secuirty04.34dd3ed0.jpg",l=r.p+"assets/img/secuirty05.23e8663d.jpg",p=r.p+"assets/img/secuirty06.b256f33b.jpg",c={},h=(0,r(6262).A)(c,[["render",function(e,i){return(0,a.uX)(),(0,a.CE)("div",null,i[0]||(i[0]=[(0,a.Fv)('<h2 id="springsecurity-oauth2-shiro" tabindex="-1"><a class="header-anchor" href="#springsecurity-oauth2-shiro"><span>springSecurity oAuth2 shiro</span></a></h2><p>oAuth2 协议 标准<br> spring 提供了资源认证授权 资源保护的解决方案<br><a href="https://www.cnblogs.com/xwgblog/p/12131527.html" target="_blank" rel="noopener noreferrer">博客园相关资料</a></p><h2 id="常用的是基于用户名和密码的认证方式" tabindex="-1"><a class="header-anchor" href="#常用的是基于用户名和密码的认证方式"><span>常用的是基于用户名和密码的认证方式</span></a></h2><figure><img src="'+t+'" alt="认证流程" tabindex="0" loading="lazy"><figcaption>认证流程</figcaption></figure><ul><li>认证：<br> 就是判断一个用户的身份是否合法的过程，用户去访问资源时系统要求验证用户的身份信是否合法，合法可以继续访问，不合法不问。</li><li>会话：<br> 用户认证通过之后，为了避免每次操作都要认证，可将用户信息保存在会话中，常见的就是session和token的方式</li><li>授权：<br> 用户认证通过后根据用户的权限来控制访问资源的过程</li></ul><h3 id="数据模型" tabindex="-1"><a class="header-anchor" href="#数据模型"><span>数据模型：</span></a></h3><p>分为三大类：<br> 1.主体（subject）2.资源（resource）3.权限（permission）<br> 主体有哪些权限可以访问哪些资源<br> 用户表——用户角色表——角色表——角色权限表——权限表（权限对应资源）<br> RBAC：<br> 基于资源的访问控制，根据用户有哪些权限资源来进行控制<br> 例如：部门组长有审批的权限标识<br> if（主体.havePermission(审批标识)）{<br> 进行审批操作。。<br> }<br> 后期需要对部门经理也有这样的权限，在角色中添加权限标识，代码就不用更改<br> 基于角色的访问控制就存在弊端</p><h2 id="基于session的认证方式" tabindex="-1"><a class="header-anchor" href="#基于session的认证方式"><span>基于session的认证方式：</span></a></h2><ol><li>用户登录，认证成功后，</li><li>在服务端将用户的信息保存在session中， k：sessionId v：用户信息</li><li>返回sessionId到客户端</li><li>客户端将sessionId保存到cookie中</li><li>再次发生请求携带cookie访问</li><li>服务端从cookie中获取sessionId 验证是否有session数据</li><li>用户退出或session过期销毁，sessionId也就无效了</li></ol><h2 id="拦截器" tabindex="-1"><a class="header-anchor" href="#拦截器"><span>拦截器</span></a></h2><p>spring-security提供了认证拦截的功能不需要自己写拦截器<br> 配置类 需要extends WebSecurityConfigurerAdapter 添加注解@EnableWebSecurity<br> 配置类中配置三个</p><ol><li>定义用户信息服务（用于查询用户信息）</li><li>密码编码器</li><li>安全拦截机制（重要 相当于拦截器）</li></ol><h2 id="过滤器" tabindex="-1"><a class="header-anchor" href="#过滤器"><span>过滤器</span></a></h2><p>springSecurity是使用filter链来实现用户请求的过滤（FilterchainProxy）<br> AuthenticationManager（认证器） AccessDecisionManager（授权器）主要由这两个来处理<br> 重要过滤器<br> securityContextPersistenceFilter 这个过滤器是整个拦截过程的入口和出口<br> UsernamePasswordAuthenticationFilter 用于处理来自表单提交的认证<br> FilterSecurityInterceptor 用于保护web资源，使用AccessDecisionManager对当前用户进行授权访问<br> ExceptionTranslationFilter 用于捕获来之FilterChain所有异常，并处理。</p><h2 id="security认证流程" tabindex="-1"><a class="header-anchor" href="#security认证流程"><span>security认证流程：</span></a></h2><ol><li>用户提交用户名密码</li><li>UsernamePasswordAuthenticationFilter拦截</li><li>AuthenticationManager</li><li>DaoAuthenticationProvider</li><li>调用userDetailsService（自定义）查询用户信息，通过密码编码器（Bcrypt常用）进行比对，权限信息填充</li><li>返回Authentication（认证信息）</li></ol><h2 id="security授权流程" tabindex="-1"><a class="header-anchor" href="#security授权流程"><span>security授权流程：</span></a></h2><ol><li>认证后的用户访问受保护资源</li><li>获取当前资源所需要的权限</li><li>accessDecisionManager投票决策（三种决策方式 默认采用只有有1票通过就决策通过的原则）</li></ol><ul><li>只要有1票支持就决策为通过</li><li>比较支持票和反对票数量来决策</li><li>只要有1票反对就决策为不通过</li></ul><h2 id="支持自定义登录页面-登出-会话" tabindex="-1"><a class="header-anchor" href="#支持自定义登录页面-登出-会话"><span>支持自定义登录页面 登出 会话</span></a></h2><p>设置session是否创建 如果是分布式系统采用token的方式保存用户信息，就可以设置为不创建session</p><h2 id="授权有两种方式-一种是web授权-基于url的拦截-一种是方法授权" tabindex="-1"><a class="header-anchor" href="#授权有两种方式-一种是web授权-基于url的拦截-一种是方法授权"><span>授权有两种方式 一种是web授权（基于url的拦截） 一种是方法授权</span></a></h2><p>方法授权：使用方法授权 需要开启注解支持 在配置类中添加@EnableGlobalMethoSecurity（securedEnabled=ture）</p><h2 id="注解" tabindex="-1"><a class="header-anchor" href="#注解"><span>注解</span></a></h2><p>@PreAuthorize（执行方法之前），@PostAuthorize（执行方法之后），@Secured<br> 使用注解都需要开启注解支持</p><h2 id="分布式系统认证方案" tabindex="-1"><a class="header-anchor" href="#分布式系统认证方案"><span>分布式系统认证方案</span></a></h2><p>对所有服务进行统一的认证<br> 对外部应用提供统一接入功能</p><p>一般会采用token的方式，不建议采用session的方式，主要是因为session需要统一存储或者session复制，对于移动互联网应用也存在问题 session是基于cookie的，移动端对cookie不能有效的使用，并存在跨域问题<br><img src="'+n+'" alt="分布式系统认证流程" loading="lazy"><br> 认证服务器 对OAuth2中的两个角色进行认证授权，分别是资源拥有者、客户端</p><h2 id="spring-security-oauth2框架" tabindex="-1"><a class="header-anchor" href="#spring-security-oauth2框架"><span>spring-security-oauth2框架</span></a></h2><p>包含对接入端 以及登录用户的合法性进行校验并颁发凭证token</p><ul><li>AuthorizationEndpoint 服务于认证请求。默认URL：/oauth/authorize</li><li>TokenEndpoint 服务于访问令牌的请求。默认URL：/oauth/token</li><li>OAuth2AuthenticationProcessingFilter 用来对请求给出的身份令牌进行解析鉴权</li></ul><h2 id="授权服务器配置" tabindex="-1"><a class="header-anchor" href="#授权服务器配置"><span>授权服务器配置</span></a></h2><p>用@EnableAuthenticationServer注解并继承AuthenticationServerConfigurerAdapter来配置oAuth授权服务器，重写父类三个方法</p><ul><li><p>ClientDetailsServerConfigurer配置客户端详情。作用是支持哪些客户端（客户端信息放到数据库中【clientId，secret,授权类型...】客户端需要通过客户端id和秘钥来申请令牌）</p></li><li><p>AuthorizationServerEndpointConfigurer配置令牌的访问端点和令牌服务（token services）。令牌单独配置在外面方便管理再注入到本类使用，令牌服务配置一个beanServices：客户端信息服务，是否刷新令牌，令牌的存储策略，令牌默认有效时间，刷新令牌默认有效时间；令牌访问端点配置：密码模式，授权码模式，令牌服务</p></li><li><p>AuthorizationServerSecurityConfigurer配置令牌端点的约束。配置提供公有秘钥端点，jwt令牌，/oauth/token_key全部放行，检测令牌端点，/oauth/check_token全部放行</p></li></ul><h2 id="令牌单独配置-tokenconfigurer" tabindex="-1"><a class="header-anchor" href="#令牌单独配置-tokenconfigurer"><span>令牌单独配置 tokenConfigurer</span></a></h2><p>令牌的存储策略 将会采用JWT令牌的方式 配置是否对称加密算法</p><h2 id="授权码模式" tabindex="-1"><a class="header-anchor" href="#授权码模式"><span>授权码模式</span></a></h2><p>最安全的模式<br><img src="'+s+'" alt="分布式系统认证流程" loading="lazy"></p><h2 id="简化模式" tabindex="-1"><a class="header-anchor" href="#简化模式"><span>简化模式</span></a></h2><p>主要针对的是没有服务器的第三方单页面应用，因为没有服务器端就无法接收授权码<br><img src="'+o+'" alt="分布式系统认证流程" loading="lazy"></p><h2 id="密码模式" tabindex="-1"><a class="header-anchor" href="#密码模式"><span>密码模式</span></a></h2><p>会将密码泄露给客户端，因此一般这种方式都是使用在自己开发的客户端<br><img src="'+l+'" alt="分布式系统认证流程" loading="lazy"></p><h2 id="客户端模式" tabindex="-1"><a class="header-anchor" href="#客户端模式"><span>客户端模式</span></a></h2><p>这种方式最方便但是最不安全，适用于完全信任的应用<br><img src="'+p+'" alt="分布式系统认证流程" loading="lazy"></p><h2 id="资源服务配置" tabindex="-1"><a class="header-anchor" href="#资源服务配置"><span>资源服务配置</span></a></h2><p>@EnableResourceServer注解来标注为是一个资源服务，并继承ResourceServerConfigurerAdapter类<br> 配置resourceId常量标识为这个资源的标识<br> 复写父类两个方法<br> 设置资源id，验证token服务（在一个项目中可以直接使用，不在一个项目中使用远程服务请求授权服务校验token，采用jwt需在项目中配置tokenconfig类）<br> http访问配置<br> 配置安全访问控制配置</p><h2 id="jwt令牌" tabindex="-1"><a class="header-anchor" href="#jwt令牌"><span>JWT令牌</span></a></h2><p>应为校验token采用的是远程较远，当访问量过大，会对性能产生影响。于是JWT就是解决这个问题的<br> 用户认证通过后得到JWT令牌，JWT令牌中包括了用户的相关信息，客户端只需要携带JWT令牌访问资源服务，资源服务会根据事先约定的算法自行对令牌校验，无需每次都请求认证服务来完成校验工作。</p><h3 id="优点" tabindex="-1"><a class="header-anchor" href="#优点"><span>优点：</span></a></h3><ul><li>jwt基于json，非常方便解析</li><li>可以在令牌中自定义丰富的的内容，扩展性高</li><li>通过非对称加密算法及数字签名技术，jwt防止被篡改，安全性高</li><li>资源服务使用jwt可自行校验并获得授权信息</li></ul><h3 id="缺点" tabindex="-1"><a class="header-anchor" href="#缺点"><span>缺点：</span></a></h3><ul><li>jwt令牌较长，占存储空间比较大（可以接受的范围内）</li></ul>',52)]))}]]),u=JSON.parse('{"path":"/programming/framework/springSecuirty.html","title":"springSecuirty","lang":"zh-CN","frontmatter":{"icon":"tree","category":["java","foundation","springSecuirty"],"tag":["java","foundation","笔记","记录","springSecuirty"],"title":"springSecuirty","star":true,"pageview":true,"description":"springSecurity oAuth2 shiro oAuth2 协议 标准 spring 提供了资源认证授权 资源保护的解决方案 博客园相关资料 常用的是基于用户名和密码的认证方式 认证流程认证流程 认证： 就是判断一个用户的身份是否合法的过程，用户去访问资源时系统要求验证用户的身份信是否合法，合法可以继续访问，不合法不问。 会话： 用户认证通过...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"springSecuirty\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-07-14T08:43:59.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"XK\\",\\"url\\":\\"https://xk1009.github.io/Xblog\\",\\"email\\":\\"564293991@qq.com\\"}]}"],["meta",{"property":"og:url","content":"https://mister-hope.github.io/Xblog/programming/framework/springSecuirty.html"}],["meta",{"property":"og:site_name","content":"树下打盹儿"}],["meta",{"property":"og:title","content":"springSecuirty"}],["meta",{"property":"og:description","content":"springSecurity oAuth2 shiro oAuth2 协议 标准 spring 提供了资源认证授权 资源保护的解决方案 博客园相关资料 常用的是基于用户名和密码的认证方式 认证流程认证流程 认证： 就是判断一个用户的身份是否合法的过程，用户去访问资源时系统要求验证用户的身份信是否合法，合法可以继续访问，不合法不问。 会话： 用户认证通过..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-07-14T08:43:59.000Z"}],["meta",{"property":"article:tag","content":"springSecuirty"}],["meta",{"property":"article:tag","content":"记录"}],["meta",{"property":"article:tag","content":"笔记"}],["meta",{"property":"article:tag","content":"foundation"}],["meta",{"property":"article:tag","content":"java"}],["meta",{"property":"article:modified_time","content":"2025-07-14T08:43:59.000Z"}]]},"git":{"createdTime":1752482639000,"updatedTime":1752482639000,"contributors":[{"name":"xk","username":"xk","email":"564293991@qq.com","commits":1,"url":"https://github.com/xk"}]},"readingTime":{"minutes":6.53,"words":1958},"filePathRelative":"programming/framework/springSecuirty.md","excerpt":"<h2>springSecurity oAuth2  shiro</h2>\\n<p>oAuth2 协议 标准<br>\\nspring 提供了资源认证授权 资源保护的解决方案<br>\\n<a href=\\"https://www.cnblogs.com/xwgblog/p/12131527.html\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">博客园相关资料</a></p>\\n<h2>常用的是基于用户名和密码的认证方式</h2>\\n<figure><figcaption>认证流程</figcaption></figure>\\n<ul>\\n<li>认证：<br>\\n就是判断一个用户的身份是否合法的过程，用户去访问资源时系统要求验证用户的身份信是否合法，合法可以继续访问，不合法不问。</li>\\n<li>会话：<br>\\n用户认证通过之后，为了避免每次操作都要认证，可将用户信息保存在会话中，常见的就是session和token的方式</li>\\n<li>授权：<br>\\n用户认证通过后根据用户的权限来控制访问资源的过程</li>\\n</ul>","autoDesc":true}')},6262:(e,i)=>{i.A=(e,i)=>{const r=e.__vccOpts||e;for(const[e,a]of i)r[e]=a;return r}}}]);