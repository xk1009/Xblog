"use strict";(self.webpackChunkx_blog=self.webpackChunkx_blog||[]).push([[6006],{1090:(e,a,i)=>{i.r(a),i.d(a,{comp:()=>p,data:()=>l});var t=i(641);const s=i.p+"assets/img/lock01.37e745dc.jpg",r=i.p+"assets/img/lock02.6fc947de.jpg",n=i.p+"assets/img/lock03.54d00177.jpg",o={},p=(0,i(6262).A)(o,[["render",function(e,a){return(0,t.uX)(),(0,t.CE)("div",null,a[0]||(a[0]=[(0,t.Fv)('<h2 id="常用的分布式锁" tabindex="-1"><a class="header-anchor" href="#常用的分布式锁"><span>常用的分布式锁</span></a></h2><h3 id="基于redis、数据库、zookeeper-来实现" tabindex="-1"><a class="header-anchor" href="#基于redis、数据库、zookeeper-来实现"><span>基于Redis、数据库、zookeeper 来实现</span></a></h3><h2 id="基于redis" tabindex="-1"><a class="header-anchor" href="#基于redis"><span>基于redis</span></a></h2><figure><img src="'+s+'" alt="redis" tabindex="0" loading="lazy"><figcaption>redis</figcaption></figure><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-java"><span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">redisTemplate</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">opsForValue</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">setIfAbsent</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(k,v)</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> 返回一个boolean</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>这种方式会产生死锁<br> 例如：如果出现异常后面代码没有执行，没有delete就会死锁，try catch finally 貌似可以解决，但是宕机情况也会死锁<br> 所以使用超时时间过期的方式<br><img src="'+r+'" alt="设置过期" loading="lazy"><br> 需要实现一个阻塞锁，尝试一直去拿锁，自旋锁<br> 不可重入，及多次拿到锁之后，会得到false<br> 解决方案是 计数的方式，加锁+1，解锁-1，当值为0的时候再delete<br> 过期时间不足以执行完代码也会释放锁，导致锁失效，注意设置好过期时间<br> 可以采取 异步的设置过期时间 异步续命的方式</p><h2 id="一个分布式锁-满足以下需求" tabindex="-1"><a class="header-anchor" href="#一个分布式锁-满足以下需求"><span>一个分布式锁，满足以下需求</span></a></h2><figure><img src="'+n+'" alt="锁的需求" tabindex="0" loading="lazy"><figcaption>锁的需求</figcaption></figure><h3 id="redisson框架可解决分布式锁" tabindex="-1"><a class="header-anchor" href="#redisson框架可解决分布式锁"><span>redisson框架可解决分布式锁</span></a></h3><h2 id="cap理论" tabindex="-1"><a class="header-anchor" href="#cap理论"><span>CAP理论</span></a></h2><p>C一致性 A可用性 P分区容错性</p><h3 id="redis-和-zookeeper-区别" tabindex="-1"><a class="header-anchor" href="#redis-和-zookeeper-区别"><span>redis 和 zookeeper 区别</span></a></h3><p>P必须满足 CA满足一个<br> reids 满足AP<br> zookeeper 满足CP<br> redis存在主从同步的时候失效得话 也会产生锁失效<br> zk更能满足 redis 容易出现以上情况</p>',13)]))}]]),l=JSON.parse('{"path":"/programming/java/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81.html","title":"分布式锁","lang":"zh-CN","frontmatter":{"icon":"lock","category":["java","foundation","基础","lock","分布式锁"],"tag":["java","foundation","笔记","记录","基础","lock","分布式锁"],"title":"分布式锁","star":true,"pageview":true,"description":"常用的分布式锁 基于Redis、数据库、zookeeper 来实现 基于redis redisredis 这种方式会产生死锁 例如：如果出现异常后面代码没有执行，没有delete就会死锁，try catch finally 貌似可以解决，但是宕机情况也会死锁 所以使用超时时间过期的方式 设置过期 需要实现一个阻塞锁，尝试一直去拿锁，自旋锁 不可重入，及...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"分布式锁\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-07-14T07:00:52.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"XK\\",\\"url\\":\\"https://xk1009.github.io/Xblog\\",\\"email\\":\\"564293991@qq.com\\"}]}"],["meta",{"property":"og:url","content":"https://mister-hope.github.io/Xblog/programming/java/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81.html"}],["meta",{"property":"og:site_name","content":"树下打盹儿"}],["meta",{"property":"og:title","content":"分布式锁"}],["meta",{"property":"og:description","content":"常用的分布式锁 基于Redis、数据库、zookeeper 来实现 基于redis redisredis 这种方式会产生死锁 例如：如果出现异常后面代码没有执行，没有delete就会死锁，try catch finally 貌似可以解决，但是宕机情况也会死锁 所以使用超时时间过期的方式 设置过期 需要实现一个阻塞锁，尝试一直去拿锁，自旋锁 不可重入，及..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-07-14T07:00:52.000Z"}],["meta",{"property":"article:tag","content":"分布式锁"}],["meta",{"property":"article:tag","content":"lock"}],["meta",{"property":"article:tag","content":"基础"}],["meta",{"property":"article:tag","content":"记录"}],["meta",{"property":"article:tag","content":"笔记"}],["meta",{"property":"article:tag","content":"foundation"}],["meta",{"property":"article:tag","content":"java"}],["meta",{"property":"article:modified_time","content":"2025-07-14T07:00:52.000Z"}]]},"git":{"createdTime":1751269860000,"updatedTime":1752476452000,"contributors":[{"name":"xk","username":"xk","email":"564293991@qq.com","commits":3,"url":"https://github.com/xk"}]},"readingTime":{"minutes":1.16,"words":348},"filePathRelative":"programming/java/分布式锁.md","excerpt":"<h2>常用的分布式锁</h2>\\n<h3>基于Redis、数据库、zookeeper 来实现</h3>\\n<h2>基于redis</h2>\\n<figure><figcaption>redis</figcaption></figure>\\n<div class=\\"language-java line-numbers-mode\\" data-highlighter=\\"shiki\\" data-ext=\\"java\\" style=\\"--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34\\"><pre class=\\"shiki shiki-themes one-light one-dark-pro vp-code\\"><code class=\\"language-java\\"><span class=\\"line\\"><span style=\\"--shiki-light:#E45649;--shiki-dark:#E5C07B\\">redisTemplate</span><span style=\\"--shiki-light:#383A42;--shiki-dark:#ABB2BF\\">.</span><span style=\\"--shiki-light:#E45649;--shiki-dark:#E5C07B\\">opsForValue</span><span style=\\"--shiki-light:#383A42;--shiki-dark:#ABB2BF\\">.</span><span style=\\"--shiki-light:#4078F2;--shiki-dark:#61AFEF\\">setIfAbsent</span><span style=\\"--shiki-light:#383A42;--shiki-dark:#ABB2BF\\">(k,v)</span><span style=\\"--shiki-light:#383A42;--shiki-dark:#E06C75\\"> 返回一个boolean</span></span></code></pre>\\n<div class=\\"line-numbers\\" aria-hidden=\\"true\\" style=\\"counter-reset:line-number 0\\"><div class=\\"line-number\\"></div></div></div>","autoDesc":true}')},6262:(e,a)=>{a.A=(e,a)=>{const i=e.__vccOpts||e;for(const[e,t]of a)i[e]=t;return i}}}]);