"use strict";(self.webpackChunkx_blog=self.webpackChunkx_blog||[]).push([[1418],{6262:(t,e)=>{e.A=(t,e)=>{const o=t.__vccOpts||t;for(const[t,r]of e)o[t]=r;return o}},7911:(t,e,o)=>{o.r(e),o.d(e,{comp:()=>n,data:()=>i});var r=o(641);const p={},n=(0,o(6262).A)(p,[["render",function(t,e){return(0,r.uX)(),(0,r.CE)("div",null,e[0]||(e[0]=[(0,r.Fv)("<p>springboot_socket<br> 不能使用@Autowired注入问题</p><p>原因：<br> socket是线程安全的，用户连接时就创建一个新的端点实例，一个端点只能保证一个线程调用，所以socket对象是多例对象；<br> 而spring是单例模式，@Autowired是在spring初始化的时候创建单例对象并注入其中，并不是在实际使用的时候再注入；<br> socket是有连接的时候再实例化，所以此时并没有注入；</p><p>解决方案：写一个工具类，通过工具类在spring容器中去获取对象。</p><p>顺便提下，通过spring来管理对象的创建默认都是单例的 通过@socpe注解来设置</p><p>对象的生命周期：单例对象在spring容器中，spring初始化时创建，spring容器销毁随之而销毁，<br> 多利对象在使用时初始化创建，在使用过程中一直存活，当对象长时间不使用，通过gc来销毁。</p>",5)]))}]]),i=JSON.parse('{"path":"/programming/framework/socket.html","title":"socket","lang":"zh-CN","frontmatter":{"icon":"wave-square","category":["java","foundation","基础","socket"],"tag":["java","foundation","笔记","记录","基础","socket"],"title":"socket","star":true,"description":"springboot_socket 不能使用@Autowired注入问题 原因： socket是线程安全的，用户连接时就创建一个新的端点实例，一个端点只能保证一个线程调用，所以socket对象是多例对象； 而spring是单例模式，@Autowired是在spring初始化的时候创建单例对象并注入其中，并不是在实际使用的时候再注入； socket是有连...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"socket\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-07-14T07:00:52.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"XK\\",\\"url\\":\\"https://xk1009.github.io/Xblog\\",\\"email\\":\\"564293991@qq.com\\"}]}"],["meta",{"property":"og:url","content":"https://mister-hope.github.io/Xblog/programming/framework/socket.html"}],["meta",{"property":"og:site_name","content":"树下打盹儿"}],["meta",{"property":"og:title","content":"socket"}],["meta",{"property":"og:description","content":"springboot_socket 不能使用@Autowired注入问题 原因： socket是线程安全的，用户连接时就创建一个新的端点实例，一个端点只能保证一个线程调用，所以socket对象是多例对象； 而spring是单例模式，@Autowired是在spring初始化的时候创建单例对象并注入其中，并不是在实际使用的时候再注入； socket是有连..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-07-14T07:00:52.000Z"}],["meta",{"property":"article:tag","content":"socket"}],["meta",{"property":"article:tag","content":"基础"}],["meta",{"property":"article:tag","content":"记录"}],["meta",{"property":"article:tag","content":"笔记"}],["meta",{"property":"article:tag","content":"foundation"}],["meta",{"property":"article:tag","content":"java"}],["meta",{"property":"article:modified_time","content":"2025-07-14T07:00:52.000Z"}]]},"git":{"createdTime":1752476452000,"updatedTime":1752476452000,"contributors":[{"name":"xk","username":"xk","email":"564293991@qq.com","commits":1,"url":"https://github.com/xk"}]},"readingTime":{"minutes":0.9,"words":271},"filePathRelative":"programming/framework/socket.md","excerpt":"<p>springboot_socket<br>\\n不能使用@Autowired注入问题</p>\\n<p>原因：<br>\\nsocket是线程安全的，用户连接时就创建一个新的端点实例，一个端点只能保证一个线程调用，所以socket对象是多例对象；<br>\\n而spring是单例模式，@Autowired是在spring初始化的时候创建单例对象并注入其中，并不是在实际使用的时候再注入；<br>\\nsocket是有连接的时候再实例化，所以此时并没有注入；</p>\\n<p>解决方案：写一个工具类，通过工具类在spring容器中去获取对象。</p>\\n<p>顺便提下，通过spring来管理对象的创建默认都是单例的 通过@socpe注解来设置</p>","autoDesc":true}')}}]);