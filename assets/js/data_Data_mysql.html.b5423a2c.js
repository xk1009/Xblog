"use strict";(self.webpackChunkx_blog=self.webpackChunkx_blog||[]).push([[9310],{6262:(a,s)=>{s.A=(a,s)=>{const i=a.__vccOpts||a;for(const[a,e]of s)i[a]=e;return i}},8071:(a,s,i)=>{i.r(s),i.d(s,{comp:()=>u,data:()=>A});var e=i(641);const n=i.p+"assets/img/mysql01.8d30a70d.jpg",l=i.p+"assets/img/mysql02.c3f203a0.jpg",t=i.p+"assets/img/mysql03.61789cbb.jpg",h=i.p+"assets/img/mysql04.ed22709a.jpg",r=i.p+"assets/img/mysql05.dcd7ed75.jpg",p=i.p+"assets/img/mysql06.f39bf6bf.jpg",d=i.p+"assets/img/mysql07.0cd28bec.jpg",c=i.p+"assets/img/mysql08.0924a6a8.jpg",o=i.p+"assets/img/mysql09.6e7afa99.jpg",g=i.p+"assets/img/mysql10.fd63f5c2.jpg",m=i.p+"assets/img/mysql11.f7fcc3cb.jpg",k=i.p+"assets/img/mysql12.e11a9b5f.jpg",y=i.p+"assets/img/mysql13.5d5e7ce3.jpg",b={},u=(0,i(6262).A)(b,[["render",function(a,s){return(0,e.uX)(),(0,e.CE)("div",null,s[0]||(s[0]=[(0,e.Fv)('<h2 id="mysql-常用存储引擎" tabindex="-1"><a class="header-anchor" href="#mysql-常用存储引擎"><span>mysql 常用存储引擎</span></a></h2><ul><li>MyIASM（5.5以前默认） innodb（5.5之后默认）</li><li>MyISAM 不支持外键，不支持事务，表锁定，缓存只缓存索引，相较性能高</li><li>innodb 支持外键，支持事务，行锁定，缓存索引还缓存真实数据（内存要求较高），相较性能低</li></ul><h2 id="索引" tabindex="-1"><a class="header-anchor" href="#索引"><span>索引</span></a></h2><p>一种是hash索引和B+tree索引，使用的是innodb引擎，默认B+tree</p><h3 id="hash索引" tabindex="-1"><a class="header-anchor" href="#hash索引"><span>hash索引</span></a></h3><ul><li>底层使用的哈希表，哈希表是一种k-v存储数据的结构；</li><li>所以多个数据在存储关系上是完全没有顺序关系的；</li><li>所以在区间查询是无法直接通过索引查询的，就需要全表扫描；</li><li>所以hash索引更适用于等值查询的场景</li></ul><h3 id="b-tree索引" tabindex="-1"><a class="header-anchor" href="#b-tree索引"><span>B+tree索引</span></a></h3><p>多路平衡查询树，它的节点是天然有序的，左节点小于父节点，父节点小于右节点，所以范围查询的时候不需要全表扫描</p><h3 id="hash和b-tree索引两者区别" tabindex="-1"><a class="header-anchor" href="#hash和b-tree索引两者区别"><span>hash和B+tree索引两者区别</span></a></h3><p>哈希索引更适用于等值查询，但是无法范围查询，原因是无法使用hash索引进行排序，hash索引不支持多列联合索引的最左匹配规则，如果有大量重复键值的情况下，hash索引的效率会很低，因为存在hash碰撞问题</p><h3 id="聚簇索引和非聚簇索引" tabindex="-1"><a class="header-anchor" href="#聚簇索引和非聚簇索引"><span>聚簇索引和非聚簇索引</span></a></h3><ul><li>在 InnoDB 里，索引B+ Tree的叶子节点存储了整行数据的是主键索引，也被称之为聚簇索引。</li><li>而索引B+ Tree的叶子节点存储了主键的值的是非主键索引，也被称之为非聚簇索引。</li><li>聚簇索引更快，因为主键索引树的叶子节点直接就是我们要查询的整行数据了。</li><li>而非主键索引的叶子节点是主键的值，查到主键的值以后，还需要再通过主键的值再进行一次查询。</li></ul><h3 id="联合索引和最左前缀匹配" tabindex="-1"><a class="header-anchor" href="#联合索引和最左前缀匹配"><span>联合索引和最左前缀匹配</span></a></h3><ul><li>对多个字段添加索引，就是联合索引</li><li>where子句中使用最频繁的一列放在最左边，因为MySQL索引查询会遵循最左前缀匹配的原则，</li><li>即最左优先，在检索数据时从联合索引的最左边开始匹配。</li><li>所以当我们创建一个联合索引的时候，如(key1,key2,key3)，</li><li>相当于创建了（key1）、(key1,key2)和(key1,key2,key3)三个索引，这就是最左匹配原则。</li></ul><h2 id="数据结构" tabindex="-1"><a class="header-anchor" href="#数据结构"><span>数据结构</span></a></h2><p>二叉树，红黑树，BTree，B+Tree， Hash(哈希)</p><h3 id="二叉树" tabindex="-1"><a class="header-anchor" href="#二叉树"><span>二叉树</span></a></h3><p>左小右大，如果顺序递增id，会产生线性结构</p><h3 id="红黑树" tabindex="-1"><a class="header-anchor" href="#红黑树"><span>红黑树</span></a></h3><figure><img src="'+n+'" alt="红黑树" tabindex="0" loading="lazy"><figcaption>红黑树</figcaption></figure><h3 id="btree" tabindex="-1"><a class="header-anchor" href="#btree"><span>BTree</span></a></h3><figure><img src="'+l+'" alt="BTree" tabindex="0" loading="lazy"><figcaption>BTree</figcaption></figure><h3 id="b-tree" tabindex="-1"><a class="header-anchor" href="#b-tree"><span>B+Tree</span></a></h3><figure><img src="'+t+'" alt="B+Tree" tabindex="0" loading="lazy"><figcaption>B+Tree</figcaption></figure><h3 id="hash-哈希" tabindex="-1"><a class="header-anchor" href="#hash-哈希"><span>hash(哈希)</span></a></h3><p>存在碰撞，不支持范围查询（因为hash算法之后不能保证 hash值有序）<br><img src="'+h+'" alt="hash" loading="lazy"><br><img src="'+r+'" alt="hash1" loading="lazy"></p><h2 id="获取数据库表结构相关信息" tabindex="-1"><a class="header-anchor" href="#获取数据库表结构相关信息"><span>获取数据库表结构相关信息</span></a></h2><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-sql"><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">SELECT</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  COLUMN_NAME 列名,</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  COLUMN_TYPE 数据类型,</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  DATA_TYPE 字段类型,</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  CHARACTER_MAXIMUM_LENGTH 长度,</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  IS_NULLABLE 是否为空,</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  COLUMN_DEFAULT 默认值,</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  COLUMN_COMMENT 备注 </span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">FROM</span></span>\n<span class="line"><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> INFORMATION_SCHEMA</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">COLUMNS</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">where</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- developerclub为数据库名称，到时候只需要修改成你要导出表结构的数据库即可</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">table_schema </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&#39;novel&#39;</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">AND</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- article为表名，到时候换成你要导出的表的名称</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- 如果不写的话，默认会查询出所有表中的数据，这样可能就分不清到底哪些字段是哪张表中的了，所以还是建议写上要导出的名名称</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">table_name  </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &#39;user_read_record&#39;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="主从配置" tabindex="-1"><a class="header-anchor" href="#主从配置"><span>主从配置</span></a></h2><p><img src="'+p+'" alt="主库配置" loading="lazy"><br><img src="'+d+'" alt="重启服务器" loading="lazy"><br><img src="'+c+'" alt="授权" loading="lazy"><br><img src="'+o+'" alt="查看二进制日志坐标" loading="lazy"><br><img src="'+g+'" alt="从库配置" loading="lazy"><br><img src="'+m+'" alt="重启服务器2" loading="lazy"><br><img src="'+k+'" alt="设置主库" loading="lazy"><br><img src="'+y+'" alt="开启同步" loading="lazy"><br> show slave status\\G 格式化展示 一行展示</p>',30)]))}]]),A=JSON.parse('{"path":"/data/Data/mysql.html","title":"MYSQL","lang":"zh-CN","frontmatter":{"icon":"table","category":["数据","mysql"],"tag":["数据","mysql","笔记","记录"],"title":"MYSQL","star":true,"pageview":true,"description":"mysql 常用存储引擎 MyIASM（5.5以前默认） innodb（5.5之后默认） MyISAM 不支持外键，不支持事务，表锁定，缓存只缓存索引，相较性能高 innodb 支持外键，支持事务，行锁定，缓存索引还缓存真实数据（内存要求较高），相较性能低 索引 一种是hash索引和B+tree索引，使用的是innodb引擎，默认B+tree hash...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"MYSQL\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-07-14T07:00:52.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"XK\\",\\"url\\":\\"https://xk1009.github.io/Xblog\\",\\"email\\":\\"564293991@qq.com\\"}]}"],["meta",{"property":"og:url","content":"https://mister-hope.github.io/Xblog/data/Data/mysql.html"}],["meta",{"property":"og:site_name","content":"树下打盹儿"}],["meta",{"property":"og:title","content":"MYSQL"}],["meta",{"property":"og:description","content":"mysql 常用存储引擎 MyIASM（5.5以前默认） innodb（5.5之后默认） MyISAM 不支持外键，不支持事务，表锁定，缓存只缓存索引，相较性能高 innodb 支持外键，支持事务，行锁定，缓存索引还缓存真实数据（内存要求较高），相较性能低 索引 一种是hash索引和B+tree索引，使用的是innodb引擎，默认B+tree hash..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-07-14T07:00:52.000Z"}],["meta",{"property":"article:tag","content":"记录"}],["meta",{"property":"article:tag","content":"笔记"}],["meta",{"property":"article:tag","content":"mysql"}],["meta",{"property":"article:tag","content":"数据"}],["meta",{"property":"article:modified_time","content":"2025-07-14T07:00:52.000Z"}]]},"git":{"createdTime":1751770540000,"updatedTime":1752476452000,"contributors":[{"name":"xk","username":"xk","email":"564293991@qq.com","commits":3,"url":"https://github.com/xk"}]},"readingTime":{"minutes":3.15,"words":944},"filePathRelative":"data/Data/mysql.md","excerpt":"<h2>mysql 常用存储引擎</h2>\\n<ul>\\n<li>MyIASM（5.5以前默认） innodb（5.5之后默认）</li>\\n<li>MyISAM 不支持外键，不支持事务，表锁定，缓存只缓存索引，相较性能高</li>\\n<li>innodb 支持外键，支持事务，行锁定，缓存索引还缓存真实数据（内存要求较高），相较性能低</li>\\n</ul>\\n<h2>索引</h2>\\n<p>一种是hash索引和B+tree索引，使用的是innodb引擎，默认B+tree</p>\\n<h3>hash索引</h3>\\n<ul>\\n<li>底层使用的哈希表，哈希表是一种k-v存储数据的结构；</li>\\n<li>所以多个数据在存储关系上是完全没有顺序关系的；</li>\\n<li>所以在区间查询是无法直接通过索引查询的，就需要全表扫描；</li>\\n<li>所以hash索引更适用于等值查询的场景</li>\\n</ul>","autoDesc":true}')}}]);